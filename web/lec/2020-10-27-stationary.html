---
title: Stationary iterations
layout: slides
audio: 2020-10-27-stationary
---

<section>
  <h1><a href="https://www.cs.cornell.edu/courses/cs5220/2020fa/">CS 5220</a></h1>
  <h2>Applications of Parallel Computers</h2>
  <h3>Stationary iterations</h3>
  <p>
    <small>Prof <a href="http://www.cs.cornell.edu/~bindel">David Bindel</a></small>
  </p>
  <p>Please click the play button below.</p>
</section>

<section>
<h3>Fixed Point Iteration</h3>
<p><img data-src="figs/fixedp.svg" title="Fixed point iteration" style="width:80.0%" /></p>
<p><span class="math inline">\(x_{k+1} = f(x_k) \rightarrow x_* = f(x_*)\)</span></p>
</section>

<section>
<h3>Iterative Idea</h3>
<ul>
<li><span class="math inline">\(f\)</span> is a <em>contraction</em> if <span class="math inline">\(\|f(x)-f(y)\| &lt; \|x-y\|\)</span>.</li>
<li><span class="math inline">\(f\)</span> has a unique <em>fixed point</em> <span class="math inline">\(x_* = f(x_*)\)</span>.</li>
<li>For <span class="math inline">\(x_{k+1} = f(x_k)\)</span>, <span class="math inline">\(x_k \rightarrow x_*\)</span>.</li>
<li>If <span class="math inline">\(\|f(x)-f(y)\| &lt; \alpha \|x-y\|\)</span>, <span class="math inline">\(\alpha &lt; 1\)</span>, for all <span class="math inline">\(x, y\)</span>, then <span class="math display">\[\|x_k-x_*\| &lt; \alpha^k \|x-x_*\|\]</span></li>
<li>Looks good <em>if</em> <span class="math inline">\(\alpha\)</span> not too near 1...</li>
</ul>
</section>

<section>
<h3>Stationary Iterations</h3>
<p>Write <span class="math inline">\(Ax = b\)</span> as <span class="math inline">\(A = M-K\)</span>; get fixed point of <span class="math display">\[M x_{k+1} = K x_k + b\]</span> or <span class="math display">\[x_{k+1} = (M^{-1} K) x_k + M^{-1} b.\]</span></p>
<ul>
<li>Convergence if <span class="math inline">\(\rho(M^{-1} K) &lt; 1\)</span></li>
<li>Best case for convergence: <span class="math inline">\(M = A\)</span></li>
<li>Cheapest case: <span class="math inline">\(M = I\)</span></li>
<li><p>Realistic: choose something between<br />
</p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">Jacobi</td>
<td style="text-align: left;"><span class="math inline">\(M = \operatorname{diag}(A)\)</span></td>
</tr>
<tr class="even">
<td style="text-align: left;">Gauss-Seidel</td>
<td style="text-align: left;"><span class="math inline">\(M = \operatorname{tril}(A)\)</span></td>
</tr>
</tbody>
</table></li>
</ul>
</section>

<section>
<h3>Reminder: Discretized 2D Poisson Problem</h3>
<p><img data-src="figs/poisson2d-stencil.svg" title="Second-order finite difference stencil for 2D Poisson" style="width:80.0%" /></p>
<p><span class="math inline">\((Lu)_{i,j} = h^{-2} \left( 4u_{i,j}-u_{i-1,j}-u_{i+1,j}-u_{i,j-1}-u_{i,j+1} \right)\)</span></p>
</section>

<section>
<h3>Jacobi on 2D Poisson</h3>
<p>Assuming homogeneous Dirichlet boundary conditions</p>
<pre><code>for step = 1:nsteps

  for i = 2:n-1
    for j = 2:n-1
      u_next(i,j) = ...
        ( u(i,j+1) + u(i,j-1) + ...
          u(i-1,j) + u(i+1,j) )/4 - ...
        h^2*f(i,j)/4;
    end
  end
  u = u_next;

end</code></pre>
<p>Basically do some averaging at each step.</p>
</section>

<section>
<h3>Parallel version (5 point stencil)</h3>
<p><img data-src="figs/poisson2d-5pt-block.svg" title="Sketch of data dependencies in a 2D Poisson scheme with 5-point stencil" style="width:50.0%" /></p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">Boundary values:</td>
<td style="text-align: left;">white</td>
</tr>
<tr class="even">
<td style="text-align: left;">Data on P0:</td>
<td style="text-align: left;">green</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Ghost cell data:</td>
<td style="text-align: left;">blue</td>
</tr>
</tbody>
</table>
</section>

<section>
<h3>Parallel version (9 point stencil)</h3>
<p><img data-src="figs/poisson2d-9pt-block.svg" title="Sketch of data dependencies in a 2D Poisson scheme with 5-point stencil" style="width:50.0%" /></p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">Boundary values:</td>
<td style="text-align: left;">white</td>
</tr>
<tr class="even">
<td style="text-align: left;">Data on P0:</td>
<td style="text-align: left;">green</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Ghost cell data:</td>
<td style="text-align: left;">blue</td>
</tr>
</tbody>
</table>
</section>

<section>
<h3>Parallel version (5 point stencil)</h3>
<p><img data-src="figs/poisson2d-swap5.svg" title="Communication pattern for 5 point stencil" style="width:60.0%" /></p>
<p>Communicate ghost cells before each step.</p>
</section>

<section>
<h3>Parallel version (9 point stencil)</h3>
<p><img data-src="figs/poisson2d-swap9ew.svg" title="Communication pattern for 9 point stencil" style="width:60.0%" /></p>
<p>Communicate in two phases (<span class="alert">EW</span>, NS) to get corners.</p>
</section>

<section>
<h3>Parallel version (9 point stencil)</h3>
<p><img data-src="figs/poisson2d-swap9ns.svg" title="Communication pattern for 9 point stencil" style="width:60.0%" /></p>
<p>Communicate in two phases (EW, <span class="alert">NS</span>) to get corners.</p>
</section>

<section>
<h3>Gauss-Seidel on 2D Poisson</h3>
<pre><code>for step = 1:nsteps

  for i = 2:n-1
    for j = 2:n-1
      u(i,j) = ...
        ( u(i,j+1) + u(i,j-1) + ...
          u(i-1,j) + u(i+1,j) )/4 - ...
        h^2*f(i,j)/4;
    end
  end

end</code></pre>
<p>Bottom values depend on top; how to parallelize?</p>
</section>

<section>
<h3>Red-Black Gauss-Seidel</h3>
<p><img data-src="figs/checker6x6.svg" title="Checkerboard pattern for red-black Gauss-Seidel" style="width:60.0%" /></p>
<p>Red depends only on black, and vice-versa.<br />
Generalization: multi-color orderings</p>
</section>

<section>
<h3>Red black Gauss-Seidel step</h3>
<pre><code>  for i = 2:n-1
    for j = 2:n-1
      if mod(i+j,2) == 0
        u(i,j) = ...
      end
    end
  end

  for i = 2:n-1
    for j = 2:n-1
      if mod(i+j,2) == 1,
      u(i,j) = ...
    end
  end</code></pre>
</section>

<section>
<h3>Parallel red-black Gauss-Seidel sketch</h3>
<p>At each step</p>
<ul>
<li>Send black ghost cells</li>
<li>Update red cells</li>
<li>Send red ghost cells</li>
<li>Update black ghost cells</li>
</ul>
</section>

<section>
<h3>More Sophistication</h3>
<ul>
<li>Successive over-relaxation (SOR): extrapolate Gauss-Seidel direction</li>
<li>Block Jacobi: let <span class="math inline">\(M\)</span> be a block diagonal matrix from <span class="math inline">\(A\)</span>
<ul>
<li>Other block variants similar</li>
</ul></li>
<li>Alternating Direction Implicit (ADI): alternately solve on vertical lines and horizontal lines</li>
<li>Multigrid</li>
</ul>
<p>These are mostly just the opening act for Krylov methods</p>
</section>

