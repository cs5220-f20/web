---
title: Locality and parallelism in simulations
layout: slides
audio: 2020-09-29-simulations
---

<section>
  <h1><a href="https://www.cs.cornell.edu/courses/cs5220/2020fa/">CS 5220</a></h1>
  <h2>Applications of Parallel Computers</h2>
  <h3>Locality and Parallelism in Simulations</h3>
  <p>
    <small>Prof <a href="http://www.cs.cornell.edu/~bindel">David Bindel</a></small>
  </p>
  <p>Please click the play button below.</p>

  <aside class="notes">
  </aside>
</section>


<section>

  <section><h2>Parallelism and locality</h2></section>


  <section>
    <h3>Parallelism and locality</h3>

    <p>Real world exhibits <em>parallelism</em> and <em>locality</em></p>
    <ul>
      <li>Particles, people, etc function independently</li>
      <li>Near-field interactions stronger than far-field</li>
      <li>Can often simplify dependence on distant objects</li>
    </ul>
  </section>


  <section>
    <h3>Parallelism and locality</h3>

    <p>Can get more parallelism / locality through model</p>
    <ul>
      <li>Limited dependency between adjacent time steps</li>
      <li>Can neglect or approximate far-field effects</li>
    </ul>
  </section>


  <section>
    <h3>Parallelism and locality</h3>

    <p>Often get parallelism at multiple levels</p>
    <ul>
      <li>Hierarchical circuit simulation</li>
      <li>Interacting models for climate</li>
      <li>Parallelizing individual experiments in MC or optimization</li>
    </ul>
  </section>


  <section>
    <h3>Basic styles of simulation</h3>
    <ul>
      <li>Discrete event systems (continuous or discrete time)</li>
      <li>Particle systems</li>
      <li>Lumped parameter models (ODEs)</li>
      <li>Distributed parameter models (PDEs / integral equations)</li>
    </ul>
    <p>Often more than one type of simulation appropriate.<br />
      Sometimes more than one at a time!</p>
  </section>

</section>


<section>

  <section><h2>Discrete event systems</h2></section>


  <section>
    <h3>Discrete event systems</h3>

    <p>May be discrete or continuous time</p>
    <ul>
      <li>Game of life, logic-level circuit simulation</li>
      <li>Network simulation</li>
    </ul>
  </section>


  <section>
    <h3>Discrete events</h3>

    <ul>
      <li>Finite set of variables, updated via transition function</li>
      <li><em>Synchronous</em> case: finite state machine</li>
      <li><em>Asynchronous</em> case: event-driven simulation</li>
      <li>Synchronous example: Game of Life</li>
      <li>Nice starting point — no discretization concerns!</li>
    </ul>
  </section>


  <section>
    <h3>Game of Life</h3>
    <p>Game of Life (John Conway):</p>
    <ol type="1">
      <li>Live cell dies with &lt; 2 live neighbors</li>
      <li>Live cell dies with &gt; 3 live neighbors</li>
      <li>Live cell lives with 2–3 live neighbors</li>
      <li>Dead cell becomes live with exactly 3 live neighbors</li>
    </ol>
  </section>


  <section>
    <h3>Game of Life</h3>
    <p>Easy to parallelize by <em>domain decomposition</em>.</p>
    <ul>
      <li>Update work involves <em>volume</em> of subdomains</li>
      <li>Communication per step on <em>surface</em> (cyan)</li>
    </ul>
  </section>


  <section>
    <h3>Game of Life: Pioneers and Settlers</h3>
    <p>What if pattern is “dilute”?</p>
    <ul>
      <li>Few or no live cells at surface at each step</li>
      <li>Think of live cell at a surface as an “event”</li>
      <li>Only communicate events!
        <ul>
          <li>This is <em>asynchronous</em></li>
          <li>Harder with message passing — when to receive?</li>
      </ul></li>
    </ul>
  </section>


  <section>
    <h3>Asynchronous Game of Life</h3>
    <p>How do we manage events?</p>
    <ul>
      <li><em>Speculative</em> — assume no communication across boundary for many steps, back up if needed</li>
      <li><em>Conservative</em> — wait when communication possible
        <ul>
          <li>possible <span class="math inline">\(\not \equiv\)</span> guaranteed!</li>
          <li>Deadlock: everyone waits for a send</li>
          <li>Can get around this with NULL messages</li>
      </ul></li>
    </ul>
  </section>


  <section>
    <h3>Asynchronous Game of Life</h3>
    <p>How do we manage load balance?</p>
    <ul>
      <li>No need to simulate quiescent parts of the game!</li>
      <li>Maybe dynamically assign smaller blocks to processors?</li>
    </ul>
  </section>


</section>


<section>


  <section><h2>Particle systems</h2></section>


  <section>
    <h3>Particle systems</h3>

    <ul>
      <li>Billiards, electrons, galaxies, ...</li>
      <li>Ants, cars, agents, ...?</li>
    </ul>
  </section>


  <section>
    <h3>Particle simulation</h3>
    <p>Particles move via Newton (<span class="math inline">\(F = ma\)</span>), with</p>
    <ul>
      <li>External forces: ambient gravity, currents, etc.</li>
      <li>Local forces: collisions, Van der Waals (<span class="math inline">\(1/r^6\)</span>), etc.</li>
      <li>Far-field forces: gravity and electrostatics (<span class="math inline">\(1/r^2\)</span>), etc.
        <ul>
          <li>Simple approximations often apply (Saint-Venant)</li>
      </ul></li>
    </ul>
  </section>


  <section>
    <h3>A forced example</h3>
    <p>Example force: <span class="math display">\[f_i = \sum_j Gm_i m_j
        \frac{(x_j-x_i)}{r_{ij}^3}
        \left(1 - \left(\frac{a}{r_{ij}}\right)^{4} \right), \qquad
        r_{ij} = \|x_i-x_j\|\]</span></p>
    <ul>
      <li>Long-range attractive force (<span class="math inline">\(r^{-2}\)</span>)</li>
      <li>Short-range repulsive force (<span class="math inline">\(r^{-6}\)</span>)</li>
      <li>Go from attraction to repulsion at radius <span class="math inline">\(a\)</span></li>
    </ul>
  </section>


  <section>
    <h3>A simple serial simulation</h3>
    <p>In <span class="smallcaps">Matlab</span>, we can write</p>
    <pre><code>npts = 100;
t = linspace(0, tfinal, npts);
[tout, xyv] = ode113(@fnbody, t, [x; v], [], m, g);
xout = xyv(:,1:length(x))&#39;;</code></pre>
    <p>... but I can’t call ode113 in C in parallel (or can I?)</p>
  </section>


  <section>
    <h3>A simple serial simulation</h3>
    <p>Maybe a fixed step leapfrog will do?</p>
    <pre><code>npts = 100;
steps_per_pt = 10;
dt = tfinal/(steps_per_pt*(npts-1));
xout = zeros(2*n, npts);
xout(:,1) = x;
for i = 1:npts-1
  for ii = 1:steps_per_pt
    x = x + v*dt;
    a = fnbody(x, m, g);
    v = v + a*dt;
  end
  xout(:,i+1) = x;
end</code></pre>
  </section>


  <section>
    <h3>Plotting particles</h3>
    <figure>
      <img data-src="figs/sph-plot.png" alt="image" style="width:90.0%" /><figcaption>image</figcaption>
    </figure>
  </section>


  <section>
    <h3>Pondering particles</h3>
    <ul>
      <li>Where do particles <q>live</q> (distributed mem)?
        <ul>
          <li>Decompose in space? By particle number?</li>
          <li>What about clumping?</li>
      </ul></li>
      <li>How are long-range force computations organized?</li>
      <li>How are short-range force computations organized?</li>
      <li>How is force computation load balanced?</li>
      <li>What are the boundary conditions?</li>
      <li>How are potential singularities handled?</li>
      <li>What integrator is used? What step control?</li>
    </ul>
  </section>


  <section>
    <h3>External forces</h3>
    <p>Simplest case: no particle interactions.</p>
    <ul>
      <li>Embarrassingly parallel (like Monte Carlo)!</li>
      <li>Could just split particles evenly across processors</li>
      <li>Is it that easy?
        <ul>
          <li>Maybe some trajectories need short time steps?</li>
          <li>Even with MC, load balance may not be trivial!</li>
      </ul></li>
    </ul>
  </section>


  <section>
    <h3>Local forces</h3>
    <ul>
      <li>Simplest all-pairs check is <span class="math inline">\(O(n^2)\)</span> (expensive)</li>
      <li>Or only check close pairs (via binning, quadtrees?)</li>
      <li>Communication required for pairs checked</li>
      <li>Usual model: domain decomposition</li>
    </ul>
  </section>


  <section>
    <h3>Local forces: Communication</h3>
    <p>Minimize communication:</p>
    <ul>
      <li>Send particles that might affect a neighbor “soon”</li>
      <li>Trade extra computation against communication</li>
      <li>Want low surface area-to-volume ratios on domains</li>
    </ul>
  </section>


  <section>
    <h3>Local forces: Load balance</h3>
    <ul>
      <li>Are particles evenly distributed?</li>
      <li>Do particles remain evenly distributed?</li>
      <li>Can divide space unevenly (e.g. quadtree/octtree)</li>
    </ul>
  </section>


  <section>
    <h3>Far-field forces</h3>
    <ul>
      <li>Every particle affects every other particle</li>
      <li>All-to-all communication required
        <ul>
          <li>Overlap communication with computation</li>
          <li>Poor memory scaling if everyone keeps everything!</li>
      </ul></li>
      <li>Idea: pass particles in a round-robin manner</li>
    </ul>
  </section>


  <section>
    <h3>Passing particles (far-field forces)</h3>
    <pre><code>copy local particles to current buf
for phase = 1:p
  send current buf to rank+1 (mod p)
  recv next buf from rank-1 (mod p)
  interact local particles with current buf
  swap current buf with next buf
end</code></pre>
  </section>


  <section>
    <h3>Passing particles (far-field forces)</h3>
    <p>Suppose <span class="math inline">\(n = N/p\)</span> particles in buffer. At each phase <span class="math display">\[\begin{aligned}
        t_{\mathrm{comm}} &amp; \approx \alpha + \beta n \\
        t_{\mathrm{comp}} &amp; \approx \gamma n^2
        \end{aligned}\]</span> So we can mask communication with computation if <span class="math display">\[n \geq
        \frac{1}{2\gamma} \left( \beta + \sqrt{\beta^2 + 4 \alpha \gamma} \right)
        &gt; \frac{\beta}{\gamma}\]</span></p>
  </section>


  <section>
    <h3>Passing particles (far-field forces)</h3>
    <p>More efficient serial code<br />
      <span class="math inline">\(\implies\)</span> larger <span class="math inline">\(n\)</span> needed to mask communication!<br />
      <span class="math inline">\(\implies\)</span> worse speed-up as <span class="math inline">\(p\)</span> gets larger (fixed <span class="math inline">\(N\)</span>)<br />
      but scaled speed-up (<span class="math inline">\(n\)</span> fixed) remains unchanged.</p>
    <p>This analysis neglects overhead term in LogP.</p>
  </section>


  <section>
    <h3>Far-field forces: particle-mesh methods</h3>
    <p>Consider <span class="math inline">\(r^{-2}\)</span> electrostatic potential interaction</p>
    <ul>
      <li>Enough charges looks like a continuum!</li>
      <li>Poisson maps charge distribution to potential</li>
      <li>Fast Poisson for regular grids (FFT, multigrid)</li>
      <li>Approx depends on mesh and particle density</li>
      <li>Can clean up leading part of approximation error</li>
    </ul>
  </section>


  <section>
    <h3>Far-field forces: particle-mesh methods</h3>
    <ul>
      <li>Map particles to mesh points (multiple strategies)</li>
      <li>Solve potential PDE on mesh</li>
      <li>Interpolate potential to particles</li>
      <li>Add correction term – acts like local force</li>
    </ul>
  </section>


  <section>
    <h3>Far-field forces: tree methods</h3>
    <ul>
      <li>Distance simplifies things
        <ul>
          <li>Andromeda looks like a point mass from here?</li>
      </ul></li>
      <li>Build a tree, approx descendants at each node</li>
      <li>Variants: Barnes-Hut, FMM, Anderson’s method</li>
      <li>More on this later in the semester</li>
    </ul>
  </section>


  <section>
    <h3>Summary of particle example</h3>
    <ul>
      <li>Model: Continuous motion of particles
        <ul>
          <li>Could be electrons, cars, whatever...</li>
      </ul></li>
      <li>Step through discretized time</li>
    </ul>
  </section>


  <section>
    <h3>Summary of particle example</h3>
    <ul>
      <li>Local interactions
        <ul>
          <li>Relatively cheap</li>
          <li>Load balance a pain</li>
      </ul></li>
      <li>All-pairs interactions
        <ul>
          <li>Obvious algorithm is expensive (<span class="math inline">\(O(n^2)\)</span>)</li>
          <li>Particle-mesh and tree-based algorithms help</li>
      </ul></li>
    </ul>
    <p>An important special case of lumped/ODE models.</p>
  </section>


</section>


<section>


  <section><h2>Lumped parameter simulations</h2></section>


  <section>
    <h3>Lumped parameter simulations</h3>
    <p>Examples include:</p>
    <ul>
      <li>SPICE-level circuit simulation
        <ul>
          <li>nodal voltages vs. voltage distributions</li>
      </ul></li>
      <li>Structural simulation
        <ul>
          <li>beam end displacements vs. continuum field</li>
      </ul></li>
      <li>Chemical concentrations in stirred tank reactor
        <ul>
          <li>concentrations in tank vs. spatially varying concentrations</li>
      </ul></li>
    </ul>
    <p>Typically involves ordinary differential equations (ODEs),<br />
      or with constraints (differential-algebraic equations, or DAEs).</p>
    <p>Often (not always) <em>sparse</em>.</p>
  </section>


  <section>
    <h3>Sparsity</h3>
    <p>Consider system of ODEs <span class="math inline">\(x&#39; = f(x)\)</span> (special case: <span class="math inline">\(f(x) = Ax\)</span>)</p>
    <ul>
      <li>Dependency graph has edge <span class="math inline">\((i,j)\)</span> if <span class="math inline">\(f_j\)</span> depends on <span class="math inline">\(x_i\)</span></li>
      <li>Sparsity means each <span class="math inline">\(f_j\)</span> depends on only a few <span class="math inline">\(x_i\)</span></li>
      <li>Often arises from physical or logical locality</li>
      <li>Corresponds to <span class="math inline">\(A\)</span> being a sparse matrix (mostly zeros)</li>
    </ul>
  </section>


  <section>
    <h3>Sparsity and partitioning</h3>
    <p>Want to partition sparse graphs so that</p>
    <ul>
      <li>Subgraphs are same size (load balance)</li>
      <li>Cut size is minimal (minimize communication)</li>
    </ul>
    <p>We’ll talk more about this later.</p>
  </section>
  <section id="types-of-analysis" class="slide level3">
    <h3>Types of analysis</h3>
    <p>Consider <span class="math inline">\(x&#39; = f(x)\)</span> (special case: <span class="math inline">\(f(x) = Ax + b\)</span>). Might want:</p>
    <ul>
      <li>Static analysis (<span class="math inline">\(f(x_*) = 0\)</span>)
        <ul>
          <li>Boils down to <span class="math inline">\(Ax = b\)</span> (e.g. for Newton-like steps)</li>
          <li>Can solve directly or iteratively</li>
          <li>Sparsity matters a lot!</li>
      </ul></li>
      <li>Dynamic analysis (compute <span class="math inline">\(x(t)\)</span> for many values of <span class="math inline">\(t\)</span>)
        <ul>
          <li>Involves time stepping (explicit or implicit)</li>
          <li>Implicit methods involve linear/nonlinear solves</li>
          <li>Need to understand stiffness and stability issues</li>
      </ul></li>
      <li>Modal analysis (compute eigenvalues of <span class="math inline">\(A\)</span> or <span class="math inline">\(f&#39;(x_*)\)</span>)</li>
    </ul>
  </section>


  <section>
    <h3>Explicit time stepping</h3>
    <ul>
      <li>Example: forward Euler</li>
      <li>Next step depends only on earlier steps</li>
      <li>Simple algorithms</li>
      <li>May have stability/stiffness issues</li>
    </ul>
  </section>


  <section>
    <h3>Implicit time stepping</h3>
    <ul>
      <li>Example: backward Euler</li>
      <li>Next step depends on itself and on earlier steps</li>
      <li>Algorithms involve solves — complication, communication!</li>
      <li>Larger time steps, each step costs more</li>
    </ul>
  </section>


  <section>
    <h3>A common kernel</h3>
    <p>In all these analyses, spend lots of time in sparse matvec:</p>
    <ul>
      <li>Iterative linear solvers: repeated sparse matvec</li>
      <li>Iterative eigensolvers: repeated sparse matvec</li>
      <li>Explicit time marching: matvecs at each step</li>
      <li>Implicit time marching: iterative solves (involving matvecs)</li>
    </ul>
    <p>We need to figure out how to make matvec fast!</p>
  </section>


  <section>
    <h3>An aside on sparse matrix storage</h3>
    <ul>
      <li>Sparse matrix <span class="math inline">\(\implies\)</span> mostly zero entries
        <ul>
          <li>Can also have “data sparseness” — representation with less than <span class="math inline">\(O(n^2)\)</span> storage, even if most entries nonzero</li>
      </ul></li>
      <li>Could be implicit (e.g. directional differencing)</li>
      <li>Sometimes explicit representation is useful</li>
      <li>Easy to get lots of indirect indexing!</li>
      <li>Compressed sparse storage schemes help</li>
    </ul>
  </section>


  <section>
    <h3>Example: Compressed sparse row storage</h3>
    <p>This can be even more compact:</p>
    <ul>
      <li>Could organize by blocks (block CSR)</li>
      <li>Could compress column index data (16-bit vs 64-bit)</li>
      <li>Various other optimizations — see OSKI</li>
    </ul>
  </section>


</section>


<section>


  <section><h2>Distributed parameter simulations</h2></section>


  <section>
    <h3>Distributed parameter problems</h3>
    <p>Mostly PDEs:</p>
    <table>
      <thead>
        <tr class="header">
          <th style="text-align: left;">Type</th>
          <th style="text-align: left;">Example</th>
          <th style="text-align: left;">Time?</th>
          <th style="text-align: left;">Space dependence?</th>
        </tr>
      </thead>
      <tbody>
        <tr class="odd">
          <td style="text-align: left;">Elliptic</td>
          <td style="text-align: left;">electrostatics</td>
          <td style="text-align: left;">steady</td>
          <td style="text-align: left;">global</td>
        </tr>
        <tr class="even">
          <td style="text-align: left;">Hyperbolic</td>
          <td style="text-align: left;">sound waves</td>
          <td style="text-align: left;">yes</td>
          <td style="text-align: left;">local</td>
        </tr>
        <tr class="odd">
          <td style="text-align: left;">Parabolic</td>
          <td style="text-align: left;">diffusion</td>
          <td style="text-align: left;">yes</td>
          <td style="text-align: left;">global</td>
        </tr>
      </tbody>
    </table>
    <p>Different types involve different communication:</p>
    <ul>
      <li>Global dependence <span class="math inline">\(\implies\)</span> lots of communication<br />
        (or tiny steps)</li>
      <li>Local dependence from finite wave speeds;<br />
        limits communication</li>
    </ul>
  </section>


  <section>
    <h3>Example: 1D heat equation</h3>
    <p>Consider flow (e.g. of heat) in a uniform rod</p>
    <ul>
      <li>Heat (<span class="math inline">\(Q\)</span>) <span class="math inline">\(\propto\)</span> temperature (<span class="math inline">\(u\)</span>) <span class="math inline">\(\times\)</span> mass (<span class="math inline">\(\rho h\)</span>)</li>
      <li>Heat flow <span class="math inline">\(\propto\)</span> temperature gradient (Fourier’s law)</li>
    </ul>
    <p><span class="math display">\[\begin{aligned}
        \frac{\partial Q}{\partial t} \propto
        h \frac{\partial u}{\partial t} &amp;\approx
        C \left[ \left( \frac{u(x-h)-u(x)}{h} \right) +
        \left( \frac{u(x)-u(x+h)}{h} \right) \right] \\
        \frac{\partial u}{\partial t} &amp;\approx
        C \left[ \frac{u(x-h)-2u(x)+u(x+h)}{h^2} \right] \rightarrow
        C \frac{\partial^2 u}{\partial x^2}
        \end{aligned}\]</span></p>
  </section>


  <section>
    <h3>Spatial discretization</h3>
    <p>Heat equation with <span class="math inline">\(u(0) = u(1) = 0\)</span> <span class="math display">\[\frac{\partial u}{\partial t} = C \frac{\partial^2 u}{\partial x^2}\]</span></p>
    <p>Spatial semi-discretization: <span class="math display">\[\frac{\partial^2 u}{\partial x^2} \approx \frac{u(x-h)-2u(x)+u(x+h)}{h^2}\]</span> Yields a system of ODEs <span class="math display">\[\frac{du}{dt} = C h^{-2} (-T) u =
        -C h^{-2}
        \begin{bmatrix}
        2 &amp; -1      &amp;   &amp;    &amp;        &amp; \\
        -1 &amp;  2      &amp; -1 &amp;    &amp;        &amp; \\
        &amp; \ddots  &amp; \ddots &amp; \ddots &amp; \\
        &amp;         &amp; -1      &amp; 2     &amp; -1 \\
        &amp;         &amp;        &amp;  -1     &amp; 2
        \end{bmatrix}
        \begin{bmatrix} u_1 \\ u_2 \\ \vdots \\ u_{n-2} \\ u_{n-1} \end{bmatrix}\]</span></p>
  </section>


  <section>
    <h3>Explicit time stepping</h3>
    <p>Approximate PDE by ODE system (“method of lines”): <span class="math display">\[\frac{du}{dt} = C h^{-2} T u\]</span> Now need a time-stepping scheme for the ODE:</p>
    <ul>
      <li>Simplest scheme is Euler: <span class="math display">\[u(t+\delta) \approx u(t) + u&#39;(t) \delta
          = \left( I - C \frac{\delta}{h^2} T \right) u(t)\]</span></li>
      <li>Taking a time step <span class="math inline">\(\equiv\)</span> sparse matvec with <span class="math inline">\(\left( I - C \frac{\delta}{h^2} T \right)\)</span></li>
      <li>This may not end well...</li>
    </ul>
  </section>


  <section>
    <h3>Explicit time stepping data dependence</h3>
    <p>Nearest neighbor interactions per step <span class="math inline">\(\implies\)</span><br />
      finite rate of numerical information propagation</p>
  </section>


  <section>
    <h3>Explicit time stepping in parallel</h3>
    <pre><code>for t = 1 to N
        communicate boundary data (&quot;ghost cell&quot;)
        take time steps locally
        end</code></pre>
  </section>


  <section>
    <h3>Overlapping communication with computation</h3>
    <pre><code>for t = 1 to N
        start boundary data sendrecv
        compute new interior values
        finish sendrecv
        compute new boundary values
        end</code></pre>
  </section>


  <section>
    <h3>Batching time steps</h3>
    <pre><code>for t = 1 to N by B
        start boundary data sendrecv (B values)
        compute new interior values
        finish sendrecv (B values)
        compute new boundary values
        end</code></pre>
  </section>


  <section>
    <h3>Explicit pain</h3>
    <p><embed data-src="figs/explicit-unstable-demo.pdf" style="width:80.0%" /><br />
      Unstable for <span class="math inline">\(\delta &gt; O(h^2)\)</span>!</p>
  </section>


  <section>
    <h3>Implicit time stepping</h3>
    <ul>
      <li>Backward Euler uses backward difference for <span class="math inline">\(d/dt\)</span> <span class="math display">\[u(t+\delta) \approx u(t) + u&#39;(t + \delta t) \delta\]</span></li>
      <li>Taking a time step <span class="math inline">\(\equiv\)</span> sparse matvec with <span class="math inline">\(\left( I + C \frac{\delta}{h^2} T \right)^{-1}\)</span></li>
      <li>No time step restriction for stability (good!)</li>
      <li>But each step involves linear solve (not so good!)
        <ul>
          <li>Good if you like numerical linear algebra?</li>
      </ul></li>
    </ul>
  </section>


  <section>
    <h3>Explicit and implicit</h3>
    <p>Explicit:</p>
    <ul>
      <li>Propagates information at finite rate</li>
      <li>Steps look like sparse matvec (in linear case)</li>
      <li>Stable step determined by fastest time scale</li>
      <li>Works fine for <em>hyperbolic</em> PDEs</li>
    </ul>
    <p>Implicit:</p>
    <ul>
      <li>No need to resolve fastest time scales</li>
      <li>Steps can be long... but expensive
        <ul>
          <li>Linear/nonlinear solves at each step</li>
          <li>Often these solves involve sparse matvecs</li>
      </ul></li>
      <li>Critical for parabolic PDEs</li>
    </ul>
  </section>


  <section>
    <h3>Poisson problems</h3>
    <p>Consider 2D Poisson <span class="math display">\[-\nabla^2 u =
        \frac{\partial^2 u}{\partial x^2} +
        \frac{\partial^2 u}{\partial y^2} = f\]</span></p>
    <ul>
      <li>Prototypical elliptic problem (steady state)</li>
      <li>Similar to a backward Euler step on heat equation</li>
    </ul>
  </section>


  <section>
    <h3>Poisson problem discretization</h3>
    <p><span class="math inline">\(u_{i,j} = h^{-2} \left( 4u_{i,j}-u_{i-1,j}-u_{i+1,j}-u_{i,j-1}-u_{i,j+1} \right)\)</span></p>
    <p><span class="math display">\[L =
        \left[
        \begin{array}{ccc|ccc|ccc}
        4 &amp; -1 &amp;    &amp; -1 &amp;    &amp;    &amp;    &amp;    &amp;    \\
        -1 &amp;  4 &amp; -1 &amp;    &amp; -1 &amp;    &amp;    &amp;    &amp;    \\
        &amp; -1 &amp;  4 &amp;    &amp;    &amp; -1 &amp;    &amp;    &amp;    \\ \hline
        -1 &amp;    &amp;    &amp;  4 &amp; -1 &amp;    &amp; -1 &amp;    &amp;    \\
        &amp; -1 &amp;    &amp; -1 &amp;  4 &amp; -1 &amp;    &amp; -1 &amp;    \\
        &amp;    &amp; -1 &amp;    &amp; -1 &amp;  4 &amp;    &amp;    &amp; -1 \\ \hline
        &amp;    &amp;    &amp; -1 &amp;    &amp;    &amp;  4 &amp; -1 &amp;    \\
        &amp;    &amp;    &amp;    &amp; -1 &amp;    &amp; -1 &amp;  4 &amp; -1 \\
        &amp;    &amp;    &amp;    &amp;    &amp; -1 &amp;    &amp; -1 &amp;  4
        \end{array}
        \right]\]</span></p>
  </section>


  <section>
    <h3>Poisson solvers in 2D/3D</h3>
    <p><span class="math inline">\(N = n^d =\)</span> total unknowns</p>
    <table>
      <thead>
        <tr class="header">
          <th style="text-align: left;">Method</th>
          <th style="text-align: left;">Time</th>
          <th style="text-align: left;">Space</th>
        </tr>
      </thead>
      <tbody>
        <tr class="odd">
          <td style="text-align: left;">Dense LU</td>
          <td style="text-align: left;"><span class="math inline">\(N^3\)</span></td>
          <td style="text-align: left;"><span class="math inline">\(N^2\)</span></td>
        </tr>
        <tr class="even">
          <td style="text-align: left;">Band LU</td>
          <td style="text-align: left;"><span class="math inline">\(N^2\)</span> (<span class="math inline">\(N^{7/3}\)</span>)</td>
          <td style="text-align: left;"><span class="math inline">\(N^{3/2}\)</span> (<span class="math inline">\(N^{5/3}\)</span>)</td>
        </tr>
        <tr class="odd">
          <td style="text-align: left;">Jacobi</td>
          <td style="text-align: left;"><span class="math inline">\(N^2\)</span></td>
          <td style="text-align: left;"><span class="math inline">\(N\)</span></td>
        </tr>
        <tr class="even">
          <td style="text-align: left;">Explicit inv</td>
          <td style="text-align: left;"><span class="math inline">\(N^2\)</span></td>
          <td style="text-align: left;"><span class="math inline">\(N^2\)</span></td>
        </tr>
        <tr class="odd">
          <td style="text-align: left;">CG</td>
          <td style="text-align: left;"><span class="math inline">\(N^{3/2}\)</span></td>
          <td style="text-align: left;"><span class="math inline">\(N\)</span></td>
        </tr>
        <tr class="even">
          <td style="text-align: left;">Red-black SOR</td>
          <td style="text-align: left;"><span class="math inline">\(N^{3/2}\)</span></td>
          <td style="text-align: left;"><span class="math inline">\(N\)</span></td>
        </tr>
        <tr class="odd">
          <td style="text-align: left;">Sparse LU</td>
          <td style="text-align: left;"><span class="math inline">\(N^{3/2}\)</span></td>
          <td style="text-align: left;"><span class="math inline">\(N \log N\)</span> (<span class="math inline">\(N^{4/3}\)</span>)</td>
        </tr>
        <tr class="even">
          <td style="text-align: left;">FFT</td>
          <td style="text-align: left;"><span class="math inline">\(N \log N\)</span></td>
          <td style="text-align: left;"><span class="math inline">\(N\)</span></td>
        </tr>
        <tr class="odd">
          <td style="text-align: left;">Multigrid</td>
          <td style="text-align: left;"><span class="math inline">\(N\)</span></td>
          <td style="text-align: left;"><span class="math inline">\(N\)</span></td>
        </tr>
      </tbody>
    </table>
    <p>Ref: Demmel, <em>Applied Numerical Linear Algebra</em>, SIAM, 1997.</p>
    <p>Remember: best MFlop/s <span class="math inline">\(\neq\)</span> fastest solution!</p>
  </section>


  <section>
    <h3>General implicit picture</h3>
    <ul>
      <li>Implicit solves or steady state <span class="math inline">\(\implies\)</span> solving systems</li>
      <li>Nonlinear solvers generally linearize</li>
      <li>Linear solvers can be
        <ul>
          <li>Direct (hard to scale)</li>
          <li>Iterative (often problem-specific)</li>
      </ul></li>
      <li>Iterative solves boil down to matvec!</li>
    </ul>
  </section>


  <section>
    <h3>PDE solver summary</h3>
    <ul>
      <li>Can be implicit or explicit (as with ODEs)
        <ul>
          <li>Explicit (sparse matvec) — fast, but short steps?
            <ul>
              <li>works fine for hyperbolic PDEs</li>
          </ul></li>
          <li>Implicit (sparse solve)
            <ul>
              <li>Direct solvers are hard!</li>
              <li>Sparse solvers turn into matvec again</li>
          </ul></li>
      </ul></li>
      <li>Differential operators turn into local mesh stencils
        <ul>
          <li>Matrix connectivity looks like mesh connectivity</li>
          <li>Can partition into subdomains that communicate only through boundary data</li>
          <li>More on graph partitioning later</li>
      </ul></li>
      <li>Not all nearest neighbor ops are equally efficient!
        <ul>
          <li>Depends on mesh structure</li>
          <li>Also depends on flops/point</li>
      </ul></li>
    </ul>
  </section>


</section>
