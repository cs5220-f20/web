---
title: Parallel LU
layout: slides
audio: 2020-10-22-lu
---

<section>
  <h1><a href="https://www.cs.cornell.edu/courses/cs5220/2020fa/">CS 5220</a></h1>
  <h2>Applications of Parallel Computers</h2>
  <h3>Parallel LU</h3>
  <p>
    <small>Prof <a href="http://www.cs.cornell.edu/~bindel">David Bindel</a></small>
  </p>
  <p>Please click the play button below.</p>
</section>

<section>
<h3>Reminder: Evolution of LU</h3>
<p>On board...</p>
</section>

<section>
<h3>Blocked GEPP</h3>
<p><img data-src="figs/gepp-find-piv.svg" title="Sketch of data accessed for pivot search" style="width:40.0%" /></p>
<p>Find pivot</p>
</section>

<section>
<h3>Blocked GEPP</h3>
<p><img data-src="figs/gepp-swap-piv.svg" title="Sketch of data accessed for pivot" style="width:40.0%" /></p>
<p>Swap pivot row</p>
</section>

<section>
<h3>Blocked GEPP</h3>
<p><img data-src="figs/gepp-update-col.svg" title="Sketch of block column update" style="width:40.0%" /></p>
<p>Update within block column</p>
</section>

<section>
<h3>Blocked GEPP</h3>
<p><img data-src="figs/gepp-update-delay.svg" title="Sketch of delayed update" style="width:40.0%" /></p>
<p>Delayed update (at end of block)</p>
</section>

<section>
<h3>Big idea</h3>
<ul>
<li><em>Delayed update</em> strategy lets us do LU fast
<ul>
<li>Could have also delayed application of pivots</li>
</ul></li>
<li>Same idea with other one-sided factorizations (QR)</li>
<li>Decent multi-core speedup with parallel BLAS!<br />
... assuming <span class="math inline">\(n\)</span> sufficiently large.</li>
</ul>
<p>Issues left over (block size? pivoting?)...</p>
</section>

<section>
<h3>Explicit parallelization of GE</h3>
<p>What to do:</p>
<ul>
<li><em>Decompose</em> into work chunks</li>
<li><em>Assign</em> work to threads in a balanced way</li>
<li><em>Orchestrate</em> communication + synchronization</li>
<li><em>Map</em> which processors execute which threads</li>
</ul>
</section>

<section>
<h3>Possible matrix layouts</h3>
<p>How should we share the matrix across ranks?</p>
</section>

<section>
<h3>1D col blocked</h3>
<p><span class="math display">\[\begin{bmatrix}
    0 &amp; 0 &amp; 0 &amp; 1 &amp; 1 &amp; 1 &amp; 2 &amp; 2 &amp; 2 \\
    0 &amp; 0 &amp; 0 &amp; 1 &amp; 1 &amp; 1 &amp; 2 &amp; 2 &amp; 2 \\
    0 &amp; 0 &amp; 0 &amp; 1 &amp; 1 &amp; 1 &amp; 2 &amp; 2 &amp; 2 \\
    0 &amp; 0 &amp; 0 &amp; 1 &amp; 1 &amp; 1 &amp; 2 &amp; 2 &amp; 2 \\
    0 &amp; 0 &amp; 0 &amp; 1 &amp; 1 &amp; 1 &amp; 2 &amp; 2 &amp; 2 \\
    0 &amp; 0 &amp; 0 &amp; 1 &amp; 1 &amp; 1 &amp; 2 &amp; 2 &amp; 2 \\
    0 &amp; 0 &amp; 0 &amp; 1 &amp; 1 &amp; 1 &amp; 2 &amp; 2 &amp; 2 \\
    0 &amp; 0 &amp; 0 &amp; 1 &amp; 1 &amp; 1 &amp; 2 &amp; 2 &amp; 2 \\
    0 &amp; 0 &amp; 0 &amp; 1 &amp; 1 &amp; 1 &amp; 2 &amp; 2 &amp; 2 
  \end{bmatrix}\]</span></p>
<aside class="notes">
<p>1D column blocked: bad load balance</p>
</aside>
</section>

<section>
<h3>1D col cyclic</h3>
<p><span class="math display">\[\begin{bmatrix}
    0 &amp; 1 &amp; 2 &amp; 0 &amp; 1 &amp; 2 &amp; 0 &amp; 1 &amp; 2 \\
    0 &amp; 1 &amp; 2 &amp; 0 &amp; 1 &amp; 2 &amp; 0 &amp; 1 &amp; 2 \\
    0 &amp; 1 &amp; 2 &amp; 0 &amp; 1 &amp; 2 &amp; 0 &amp; 1 &amp; 2 \\
    0 &amp; 1 &amp; 2 &amp; 0 &amp; 1 &amp; 2 &amp; 0 &amp; 1 &amp; 2 \\
    0 &amp; 1 &amp; 2 &amp; 0 &amp; 1 &amp; 2 &amp; 0 &amp; 1 &amp; 2 \\
    0 &amp; 1 &amp; 2 &amp; 0 &amp; 1 &amp; 2 &amp; 0 &amp; 1 &amp; 2 \\
    0 &amp; 1 &amp; 2 &amp; 0 &amp; 1 &amp; 2 &amp; 0 &amp; 1 &amp; 2 \\
    0 &amp; 1 &amp; 2 &amp; 0 &amp; 1 &amp; 2 &amp; 0 &amp; 1 &amp; 2 \\
    0 &amp; 1 &amp; 2 &amp; 0 &amp; 1 &amp; 2 &amp; 0 &amp; 1 &amp; 2 
  \end{bmatrix}\]</span></p>
<aside class="notes">
<p>1D column cyclic: hard to use BLAS2/3</p>
</aside>
</section>

<section>
<h3>1D col block cyclic</h3>
<p><span class="math display">\[\begin{bmatrix}
    0 &amp; 0 &amp; 1 &amp; 1 &amp; 2 &amp; 2 &amp; 0 &amp; 0 &amp; 1 &amp; 1 \\
    0 &amp; 0 &amp; 1 &amp; 1 &amp; 2 &amp; 2 &amp; 0 &amp; 0 &amp; 1 &amp; 1 \\
    0 &amp; 0 &amp; 1 &amp; 1 &amp; 2 &amp; 2 &amp; 0 &amp; 0 &amp; 1 &amp; 1 \\
    0 &amp; 0 &amp; 1 &amp; 1 &amp; 2 &amp; 2 &amp; 0 &amp; 0 &amp; 1 &amp; 1 \\
    0 &amp; 0 &amp; 1 &amp; 1 &amp; 2 &amp; 2 &amp; 0 &amp; 0 &amp; 1 &amp; 1 \\
    0 &amp; 0 &amp; 1 &amp; 1 &amp; 2 &amp; 2 &amp; 0 &amp; 0 &amp; 1 &amp; 1 \\
    0 &amp; 0 &amp; 1 &amp; 1 &amp; 2 &amp; 2 &amp; 0 &amp; 0 &amp; 1 &amp; 1 \\
    0 &amp; 0 &amp; 1 &amp; 1 &amp; 2 &amp; 2 &amp; 0 &amp; 0 &amp; 1 &amp; 1 \\
    0 &amp; 0 &amp; 1 &amp; 1 &amp; 2 &amp; 2 &amp; 0 &amp; 0 &amp; 1 &amp; 1 \\
    0 &amp; 0 &amp; 1 &amp; 1 &amp; 2 &amp; 2 &amp; 0 &amp; 0 &amp; 1 &amp; 1
  \end{bmatrix}\]</span></p>
<aside class="notes">
<p>1D column block cyclic: block column factorization a bottleneck</p>
</aside>
</section>

<section>
<h3>Block skewed</h3>
<p><span class="math display">\[\begin{bmatrix}
    0 &amp; 0 &amp; 0 &amp; 1 &amp; 1 &amp; 1 &amp; 2 &amp; 2 &amp; 2 \\
    0 &amp; 0 &amp; 0 &amp; 1 &amp; 1 &amp; 1 &amp; 2 &amp; 2 &amp; 2 \\
    0 &amp; 0 &amp; 0 &amp; 1 &amp; 1 &amp; 1 &amp; 2 &amp; 2 &amp; 2 \\
    2 &amp; 2 &amp; 2 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 1 &amp; 1 \\
    2 &amp; 2 &amp; 2 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 1 &amp; 1 \\
    2 &amp; 2 &amp; 2 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 1 &amp; 1 \\
    1 &amp; 1 &amp; 1 &amp; 2 &amp; 2 &amp; 2 &amp; 0 &amp; 0 &amp; 0 \\
    1 &amp; 1 &amp; 1 &amp; 2 &amp; 2 &amp; 2 &amp; 0 &amp; 0 &amp; 0 \\
    1 &amp; 1 &amp; 1 &amp; 2 &amp; 2 &amp; 2 &amp; 0 &amp; 0 &amp; 0 
  \end{bmatrix}\]</span></p>
<aside class="notes">
<p>Block skewed: indexing gets messy</p>
</aside>
</section>

<section>
<h3>2D block cyclic</h3>
<p><span class="math display">\[\begin{bmatrix}
    0 &amp; 0 &amp; 1 &amp; 1 &amp; 0 &amp; 0 &amp; 1 &amp; 1 \\
    0 &amp; 0 &amp; 1 &amp; 1 &amp; 0 &amp; 0 &amp; 1 &amp; 1 \\
    2 &amp; 2 &amp; 3 &amp; 3 &amp; 2 &amp; 2 &amp; 3 &amp; 3 \\
    2 &amp; 2 &amp; 3 &amp; 3 &amp; 2 &amp; 2 &amp; 3 &amp; 3 \\
    0 &amp; 0 &amp; 1 &amp; 1 &amp; 0 &amp; 0 &amp; 1 &amp; 1 \\
    0 &amp; 0 &amp; 1 &amp; 1 &amp; 0 &amp; 0 &amp; 1 &amp; 1 \\
    2 &amp; 2 &amp; 3 &amp; 3 &amp; 2 &amp; 2 &amp; 3 &amp; 3 \\
    2 &amp; 2 &amp; 3 &amp; 3 &amp; 2 &amp; 2 &amp; 3 &amp; 3 \\
  \end{bmatrix}\]</span></p>
</section>

<section>
<h3>Possible matrix layouts</h3>
<ul>
<li>1D col blocked: bad load balance</li>
<li>1D col cyclic: hard to use BLAS2/3</li>
<li>1D col block cyclic: factoring col a bottleneck</li>
<li>Block skewed (a la Cannon): just complicated</li>
<li>2D row/col block: bad load balance</li>
<li>2D row/col block cyclic: win!</li>
</ul>
</section>

<section>
<h3>Distributed GEPP</h3>
<p><img data-src="figs/dgepp-find-piv.svg" title="Sketch of data accessed for pivot search" style="width:40.0%" /></p>
<p>Find pivot (column broadcast)</p>
</section>

<section>
<h3>Distributed GEPP</h3>
<p><img data-src="figs/dgepp-swap-piv.svg" title="Sketch of data for pivot swap" style="width:40.0%" /></p>
<p>Swap pivot row within block column + broadcast pivot</p>
</section>

<section>
<h3>Distributed GEPP</h3>
<p><img data-src="figs/dgepp-update-col.svg" title="Sketch of block column update" style="width:40.0%" /></p>
<p>Update within block column</p>
</section>

<section>
<h3>Distributed GEPP</h3>
<p><img data-src="figs/dgepp-swaps-bcast.svg" title="Sketch of swap broadcast" style="width:40.0%" /></p>
<p>At end of block, broadcast swap info along rows</p>
</section>

<section>
<h3>Distributed GEPP</h3>
<p><img data-src="figs/dgepp-swaps-apply.svg" title="Sketch of swap application" style="width:40.0%" /></p>
<p>Apply all row swaps to other columns</p>
</section>

<section>
<h3>Distributed GEPP</h3>
<p><img data-src="figs/dgepp-L-bcast.svg" title="Sketch of L block broadcast" style="width:40.0%" /></p>
<p>Broadcast block <span class="math inline">\(L_{II}\)</span> right</p>
</section>

<section>
<h3>Distributed GEPP</h3>
<p><img data-src="figs/dgepp-row-update.svg" title="Sketch of row update" style="width:40.0%" /></p>
<p>Update remainder of block row</p>
</section>

<section>
<h3>Distributed GEPP</h3>
<p><img data-src="figs/dgepp-row-bcast.svg" title="Sketch of block row broadcast" style="width:40.0%" /></p>
<p>Broadcast rest of block row down</p>
</section>

<section>
<h3>Distributed GEPP</h3>
<p><img data-src="figs/dgepp-col-bcast.svg" title="Sketch of block col broadcast" style="width:40.0%" /></p>
<p>Broadcast rest of block col right</p>
</section>

<section>
<h3>Distributed GEPP</h3>
<p><img data-src="figs/dgepp-schur.svg" title="Sketch of Schur complement update" style="width:40.0%" /></p>
<p>Update of trailing submatrix</p>
</section>

<section>
<h3>Cost of ScaLAPACK GEPP</h3>
<p>Communication costs:</p>
<ul>
<li>Lower bound: <span class="math inline">\(O(n^2/\sqrt{P})\)</span> words, <span class="math inline">\(O(\sqrt{P})\)</span> messages</li>
<li>ScaLAPACK:
<ul>
<li><span class="math inline">\(O(n^2 \log P / \sqrt{P})\)</span> words sent</li>
<li><span class="math inline">\(O(n \log p)\)</span> messages</li>
<li>Problem: reduction to find pivot in each column</li>
</ul></li>
<li>Tournaments for stability without partial pivoting</li>
</ul>
<p>If you don’t care about dense LU?<br />
Let’s review some ideas in a different setting...</p>
</section>

<section>
<h3>Floyd-Warshall</h3>
<p>Goal: All pairs shortest path lengths.<br />
Idea: Dynamic programming! Define <span class="math display">\[d_{ij}^{(k)} =
    \mbox{shortest path $i$ to $j$ with intermediates in $\{1, \ldots, k\}$}.\]</span> Then <span class="math display">\[d_{ij}^{(k)} = 
    \min\left( d_{ij}^{(k-1)}, d_{ik}^{(k-1)} + d_{kj}^{(k-1)} \right)\]</span> and <span class="math inline">\(d_{ij}^{(n)}\)</span> is the desired shortest path length.</p>
</section>

<section>
<h3>The same and different</h3>
<p>Floyd’s algorithm for all-pairs shortest paths:</p>
<pre><code>for k=1:n
  for i = 1:n
    for j = 1:n
      D(i,j) = min(D(i,j), D(i,k)+D(k,j));</code></pre>

<p>Unpivoted Gaussian elimination (overwriting <span class="math inline">\(A\)</span>):</p>
<pre><code>for k=1:n
  for i = k+1:n
    A(i,k) = A(i,k) / A(k,k);
    for j = k+1:n
      A(i,j) = A(i,j)-A(i,k)*A(k,j);</code></pre>
</section>

<section>
<h3>The same and different</h3>
<ul>
<li>The same: <span class="math inline">\(O(n^3)\)</span> time, <span class="math inline">\(O(n^2)\)</span> space</li>
<li>The same: can’t move <span class="math inline">\(k\)</span> loop (data dependencies)
<ul>
<li>... at least, can’t without care!</li>
<li>Different from matrix multiplication</li>
</ul></li>
<li>The same: <span class="math inline">\(x_{ij}^{(k)} = f\left(x_{ij}^{(k-1)},  g\left(x_{ik}^{(k-1)}, x_{kj}^{(k-1)}\right)\right)\)</span>
<ul>
<li>Same basic dependency pattern in updates!</li>
<li>Similar algebraic relations satisfied</li>
</ul></li>
<li>Different: Update to full matrix vs trailing submatrix</li>
</ul>
</section>

<section>
<h3>How far can we get?</h3>
<p>How would we write</p>
<ul>
<li>Cache-efficient (blocked) <em>serial</em> implementation?</li>
<li>Message-passing <em>parallel</em> implementation?</li>
</ul>
<p>The full picture could make a fun class project...</p>
</section>

<section>
<h3>Onward!</h3>
<p>Next up: Sparse linear algebra and iterative solvers!</p>
</section>

